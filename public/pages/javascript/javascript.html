<main class="flex-1 max-w-5xl mx-auto py-12 px-4 md:px-8">
  <div class="bg-white shadow-custom rounded-lg p-6 md:p-12">

    <div class="border-b border-secondary-200 pb-6 mb-10">
      <h1 class="text-4xl font-bold text-primary-700 mb-2">JavaScript</h1>
    </div>

    <div class="prose lg:prose-lg max-w-none">

      <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4 text-primary-800">Contents</h2>
        <ul class="space-y-2">
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">1</span>
            <a href="#data-types" class="text-primary-600 hover:underline">Data types in JavaScript</a>
          </li>
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">2</span>
            <a href="#scopes" class="text-primary-600 hover:underline">Scopes in JavaScript</a>
          </li>
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">3</span>
            <a href="#functions" class="text-primary-600 hover:underline">Functions in JavaScript</a>
          </li>
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">4</span>
            <a href="#loops" class="text-primary-600 hover:underline">Loops in JavaScript</a>
          </li>
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">5</span>
            <a href="#dates" class="text-primary-600 hover:underline">Dates in JavaScript</a>
          </li>
          <li class="flex items-center">
            <span
              class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">6</span>
            <a href="#fetching" class="text-primary-600 hover:underline">Fetching in JavaScript</a>
          </li>
        </ul>
      </div>

      <section id="data-types" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">1</span>
          Data types in JavaScript
        </h2>

        <p class="text-secondary-700 leading-relaxed">
          JavaScript has 8 data types:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const StringExample = "I am a string";
const NumberExample = 42;
const BigIntExample = 9007199254740991n;
const BooleanExample = true;
const UndefinedExample = undefined;
const NullExample = null;
const SymbolExample = Symbol("unique");
const ObjectExample = { key: "value" };
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Type coercion</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Type coercion is when JavaScript converts one data type into another when performing operations between
          different types. In general you can say there are two types of coercion: implicit coercion, which happens
          automatically, and explicit coercion, where you as a developer handle it manually.
        </p>

        <p class="font-semibold text-secondary-700 leading-relaxed">Examples of implicit coercion:</p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(5 + "10"); //  “510” (number coerced into a string)
console.log("5" - 1); // 4 (string coerced into a number)
console.log(true + 1); // 2 (boolean coerced into number)
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Examples of explicit coercion:</p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(Number("10")); // 10
console.log(String(10)); // “10”
console.log(Boolean(1)); // true
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          So why is this an issue? It can lead to unintended behaviour that can create bugs due to unexpected type
          changes. It also makes your code stink, making it harder to read and maintain. So how can we avoid this?
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The first thing you can implement in your code is to always use strict equality defined by === instead of
          non strict ==. Strict equality does not perform type conversion. So as an example if you have an if
          statement, don’t use loose comparisons like == and != but instead use the strict equality.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
if (userInput === "yes") {
  console.log("User agreed");
}
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Explicitly convert types, instead of relying on implicit conversion, manually convert them yourself:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
let num = "42";
let convertedNum = Number(num);
console.log(convertedNum + 10); // 52
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The last thing we can do is to avoid mixing types in our operation.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
let num = "5";
console.log(Number(num) + 5); // 10
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Instead of doing it like this:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(num + 5); // “55” (string concatenation)
</code>
        </pre>

        <div class="bg-primary-50 p-5 rounded-lg mb-6 border-l-4 border-primary-300">
          <p class="text-secondary-700 leading-relaxed">
            Or just fucking use TypeScript as this solves all these issues.
          </p>
        </div>
      </section>

      <section id="scopes" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">2</span>
          Scopes in JavaScript
        </h2>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Scopes in JavaScript has three main types:
        </p>
        <ul class="space-y-2 mb-6">
          <li class="flex items-center text-secondary-700">
            <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
            Global scope
          </li>
          <li class="flex items-center text-secondary-700">
            <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
            Function scope
          </li>
          <li class="flex items-center text-secondary-700">
            <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
            Block scope
          </li>
        </ul>

        <p class="font-semibold text-secondary-700 leading-relaxed">Global scope</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Variables declared outside of any function or block are defined as having global scope. You can access
          these variables from anywhere in your code.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const globalVariable = "You can access me anywhere";

function example() {
  console.log(globalVariable); // Accessible inside function
}

example(); // Output: “You can access me anywhere”
console.log(globalVariable); // Same output as above
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Function scope</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Variables declared inside a function are only accessible within the function where they are declared:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function testFunction() {
  const functionScopedConst = "I  only exist inside this function";
  console.log(functionScopedConst);
}

testFunction(); // Output: “I only exist inside this function”;
console.log(functionScopedConst); // ReferenceError: functionScopedConst is not defined
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Block scope</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Variables defined inside a block, which is declared by { }, like loops or conditionals, can only be
          accessed within this block. Here it’s important to notice that only let and const are block-scoped, var is
          not, and are one of the reasons why we should never use var. This can be seen in this example:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
if (true) {
  var a = "I’m var";
  let b = "I’m let";
  const c = "I’m const";
}

console.log(a); // “I’m var”
console.log(b); // Referenceerror: b is not defined
console.log(c); // ReferenceError: c is not defined
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Why do we prefer const then?</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Using const clarifies our intention, protects against us accidently reassigning, and improves the
          predictability of our code. It is important to note that const does not prevent mutations, it just
          prevents reassignments. If you want to make a object or array immutable, you can use JavaScripts build in
          method Object.freeze()
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const obj = Object.freeze({ name: "Aleksander" });
obj.name = "Anders"; // this will fail silently, unless you are using strict mode, then it will throw an error
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          So in summary we can say that the best practice for defining variables in Javascript are as following:
        </p>

        <ul class="space-y-2 mb-6 text-secondary-700 leading-relaxed list-outside list-disc ml-6">
          <li>Always use const by default as it clearly expresses your intent and prevents accidental reassignment
          </li>
          <li>Use let only when reassignment is absolutely needed</li>
          <li>Never use var in modern JavaScript</li>
        </ul>
      </section>

      <section id="functions" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">3</span>
          Functions in JavaScript
        </h2>

        <p class="text-secondary-700 leading-relaxed mb-4">
          When working with functions in JavaScript it is important to know about hoisting, function expressions,
          arrow functions and callbacks. Let’s work our way through these, and attempt to define them.
        </p>

        <p class="font-semibold text-secondary-700 leading-relaxed">Hoisting</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Hoisting means that function declarations are lifted into the top of the scope they are declared in before
          the code. In other words, you can call a function before it is defined in the code.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(getRandomInt(0,10));  // Works even though function is defined later

function getRandomInt(min, max){
  return Math.floor(Math.random() * (max + 1 - min) - min);
}
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The function getRandomInt is what we call a function declaration, so it is being hoisted to the top of our
          script. This allows us to call getRandomInt(0,10) before its definition.
        </p>

        <p class="font-semibold text-secondary-700 leading-relaxed">Function expressions vs arrow functions</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Compared to function declarations, function expressions and arrow functions are not being hoisted. Let’s
          look at an example of function expression first.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const getRandomIntAnonymousFunction = function (min, max) {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The function is stored inside of a variable, and since const and let are not hoisted in the same way as a
          function declaration, making it impossible for us to call it before it is defined. The same goes for if we
          had defined it as an arrow function stored in a variable.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const getRandomIntArrowFunction = (min, max) => {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Callbacks</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          A callback is a function that can be passed as an argument to another function, but doesn’t have to be
          passed. An example of this could be:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function genericPerformer(name, action) {
  return action(name); // Calls the function that was passed in
}
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The genericPerformer function accepts another function (action) as a parameter and calls it
          This is also called a high-order function, as it takes another function as an argument
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4">
          So this makes it possible for us to use it like this:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const codingAction = (name) => `${name} likes coding.`;
console.log(genericPerformer("Lasse", codingAction));
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          The function codingAction is passed to our genericPerformer function, which will call it with the
          parameter “Lasse”
        </p>

        <p class="font-semibold text-secondary-700 leading-relaxed">Passing anonymous functions as callbacks</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          As just shown with defining a separate function first, you can pass it directly as an anonymous function
          as the argument. This can be done like this:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(genericPerformer("Patrick", (name) => `${name} owns at boxing`));
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          instead of writing it like this:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function boxingAction(name) {
  return `${name} owns at boxing`;
}
console.log(genericPerformer("Patrick", boxingAction));
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          This use of an inline arrow function makes our code short and also more readable.
        </p>
      </section>

      <section id="loops" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">4</span>
          Loops in JavaScript
        </h2>

        <p class="text-secondary-700 leading-relaxed mb-4">
          In JavaScript adopting a functional programming approach when working with arrays, promotes code that
          doesn’t stink, is more readable and maintainable. Using methods like map, filter and reduce allows us as
          developers to process data as pure functions, making them immutable, and without relying on explicit
          loops, and thereby minimizing side effects and maintaining high code predictability. Using these
          functional methods will make sure that we are not editing on the actual array, but instead creating a new
          one, which leads to no side effects. Let’s go through the ways of working with arrays in a functional way.
          Let’s look at some code examples:
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
// Example array
const numbers = [1, 2, 3, 4, 5]

// map - transforms each element and returns a new array
const doubled = numbers.map(num => num * 2);
// result: [2, 4, 6, 8, 10]

// filter - select elements that match a certain condition
const evens = numbers.filter(num => num % 2 === 0);
// result: [2, 4]

// reduce - accumulates values into a single result
const sum = numbers.reduce((total, num) => total + num, 0);
// result: 15
</code>
        </pre>

        <p class="font-semibold text-secondary-700 leading-relaxed">Choosing the right method for the right purpose
        </p>
        <ul class="space-y-2 mb-6 text-secondary-700 leading-relaxed list-outside list-disc ml-6">
          <li>Use map whenever we need to transform each element of an array into something else</li>
          <li>Use filter when we need to select a subset of the elements based on a certain condition</li>
          <li>Use reduce when we need to combine the elements of an array into a single value or structure</li>
          <li>Use a for loop only when finger counting</li>
        </ul>
      </section>

      <section id="dates" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">5</span>
          Dates in JavaScript
        </h2>


        <p class="text-secondary-700 leading-relaxed mb-4">
          The JavaScript Date object allows us as developers to use and manipulate dates and times in our JavaScript applications. There are multiple ways of creating a new instance of Date.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
const currentDate = new Date(); // Gets the current date and time
console.log(currentDate);
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          This will give us an output that contains the current date and time in UTC format:
          YYYY-MM-DDTHH:MM:SSZ (e.g., 2025-03-16T12:00:00Z)
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4">
          You can also get the Local date and time for the timezone you are currently in, so in our case Central European Standard time (Cest):
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
console.log(Date());
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Output:
          Wed Mar 16 2025 14:30:45 GMT+0100 (Central European Standard Time)
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4">
          So this is all good for getting full dates in whatever format fits your purpose. But how can we get specific parts of the date, so we can manipulate these? By using JavaScript’s built-in methods.
        </p>

        <h3 class="text-xl font-semibold mb-4 text-primary-800">Getting the current month</h3>
        <p class="text-secondary-700 leading-relaxed mb-4">
          In JavaScript we have multiple ways to retrieve the month:
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4 font-semibold">Method 1: Using getMonth()</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          The getMonth() method returns an index number (0 for January, 1 for February and so on)
          To link this with an actual month name we can use an array of month names.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
const monthNames = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
];

app.get("/months", (req, res) => {
    let currentDate = new Date();
    let currentMonth = monthNames[currentDate.getMonth()]; 

    res.send({ data: currentMonth });
    console.log(currentMonth);
});
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Then we will get this response in JSON:
          { "data": "March" }
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4 font-semibold">Method 2: Using toLocaleString()</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          The toLocaleString() method can format dates by using a given locale, so by doing this we convert the date into a string, formatted according to a locale, which gives us the date based on regional settings such as language and calendar system.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
app.get("/months/v1", (req, res) => {
    let currentDate = new Date();
    let currentMonth = currentDate.toLocaleString("en-US", { month: "short" }); 

    res.send({ data: currentMonth });
    console.log(currentMonth);
});
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Then we will get this response:
          { "data": "Mar" }
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4 font-semibold">Method 3: Splitting the string returned by Date()</p>
        <p class="text-secondary-700 leading-relaxed mb-4">
          A third way to retrieve the current month is to split the string that we get returned by Date() and then take the second word in that string, which represents the month, hence our format being: YYYY-MM-DDTHH:MM:SSZ.
        </p>

        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
app.get("/months/v3", (req, res) => {
    const currentMonth = Date().split(" ")[1];

    res.send({ data: currentMonth });
});
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Then we will get this JSON response:
          { "data": "Mar" }
        </p>

        <h3 class="text-xl font-semibold mb-4 text-primary-800">Getting the current day of the week</h3>
        <p class="text-secondary-700 leading-relaxed mb-4">
          Just like with months, we can retrieve the current day in different ways. It is the exact same approach as used when doing it for the current month, so I’ll just show one example here with using toLocaleString()
        </p>

        <p class="text-secondary-700 leading-relaxed mb-4 font-semibold">Using toLocaleString()</p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto"><code class="language-javascript">
app.get("/days", (req, res) => {
    let currentDate = new Date();
    let currentWeekDay = currentDate.toLocaleString("en-US", { weekday: "long"});

    res.send({ data: currentWeekDay});
});
</code></pre>

        <p class="text-secondary-700 leading-relaxed mb-4">
          Then we will get this JSON response:
          { "data": "Sunday" }
        </p>

      </section>

      <section id="fetching" class="space-y-6 mb-12">
        <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
          <span
            class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">6</span>
          Fetching in JavaScript
        </h2>

        <p class="text-secondary-700 leading-relaxed">
          To be able to send and load data between our server and client, we can use fetch to utilize this, by making API requests efficiently in JavaScript. The fetch API provides a way to make HTTP requests in JavaScript, using a promise-based interface for us to create network requests.
        </p>

        <h3 class="text-xl font-semibold mb-4 text-primary-800">Syntax</h3>
        <p class="text-secondary-700 leading-relaxed">
          The fetch function takes an URL as an argument and returns a Promise that resolves into the Response object. If nothing else is clarified, fetch makes a GET request:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
</code>
        </pre>

        <p class="text-secondary-700 leading-relaxed">
          So here you can see we added a .catch() clause, which is for error handling. We can improve this a bit, as this functionality only catches network failures in the .catch() block.  Errors can also occur at a different stage, and that is if we have an HTTP error. We can handle this by adding a response.ok check like this:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
</code>
        </pre>

        <h3 class="text-xl font-semibold mb-4 text-primary-800">Making a POST request and sending headers</h3>
        <p class="text-secondary-700 leading-relaxed">
          As said, fetches by default makes a GET request, but we can also use it to send POST requests. We can obtain this by adding a method: ‘POST’ to our fetch call, providing it with a body and headers, like this:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
</code>
        </pre>
        <p class="text-secondary-700 leading-relaxed">
          In your headers option you can add additional headers if needed. E.g if your application is using some kind of token for authorization, this can be added here, to follow the format of your security library, e.g. JSON web token,  oauth2 token etc.
        </p>

        <h3 class="text-xl font-semibold mb-4 text-primary-800">Async</h3>
        <p class="text-secondary-700 leading-relaxed">
          Due to fetch promise based nature it also operates asynchronously. This means that when we do a fetch call, the browser will start the network request but JavaScript does not wait for this request to be completed/fulfilled before moving on to the next lines of code. Instead it will return a promise, that will then eventually resolve with the response.
        </p>
        <p class="text-secondary-700 leading-relaxed">
          This non-blocking behaviour is very important because it allows our application to remain responsive while it’s waiting for data from the server. If we didn’t have this, the entire page would freeze until the request completes. As an example:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log("Fetching data...");
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log("Data received:", data))
  .catch(error => console.error('Error:', error));

console.log("This will log before the data is received!");
</code>
        </pre>
        <p class="text-secondary-700 leading-relaxed">
          So normally JavaScript is executed line for line, and it would pause until the request was finished, blocking all other tasks and we would then have this output order:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
Fetching data…
Data received: {...}
This will log before the data is received!
</code>
        </pre>
        <p class="text-secondary-700 leading-relaxed">
          Instead our actual output order due to fetch() being asynchronous:
        </p>
        <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
Fetching data…
This will log before the data is received!
Data received: {...}
</code>
        </pre>
      </section>

    </div>
  </div>
</main>
