<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JavaScript Documentation</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="../assets/js/tailwind-config.js"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
</head>

<body class="bg-secondary-50 antialiased text-secondary-800">

  <div class="min-h-screen flex">
    <div id="sidebar-container" class="flex-shrink-0"></div>

    <main class="flex-1 max-w-5xl mx-auto py-12 px-4 md:px-8">
      <div class="bg-white shadow-custom rounded-lg p-6 md:p-12">

        <div class="border-b border-secondary-200 pb-6 mb-10">
          <h1 class="text-4xl font-bold text-primary-700 mb-2">JavaScript</h1>
        </div>

        <div class="prose lg:prose-lg max-w-none">
          
          <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-primary-800">Contents</h2>
            <ul class="space-y-2">
              <li class="flex items-center">
                <span class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">1</span>
                <a href="#data-types" class="text-primary-600 hover:underline">Data types in JavaScript</a>
              </li>
              <li class="flex items-center">
                <span class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">2</span>
                <a href="#scopes" class="text-primary-600 hover:underline">Scopes in JavaScript</a>
              </li>
              <li class="flex items-center">
                <span class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">3</span>
                <a href="#functions" class="text-primary-600 hover:underline">Functions in JavaScript</a>
              </li>
              <li class="flex items-center">
                <span class="inline-block w-5 h-5 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">4</span>
                <a href="#loops" class="text-primary-600 hover:underline">Loops in JavaScript</a>
              </li>
            </ul>
          </div>

          <section id="data-types" class="space-y-6 mb-12">
            <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
              <span class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">1</span>
              Data types in JavaScript
            </h2>

            <p class="text-secondary-700 leading-relaxed">
              JavaScript has 8 data types:
            </p>
            
            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const StringExample = "I am a string";
const NumberExample = 42;
const BigIntExample = 9007199254740991n;
const BooleanExample = true;
const UndefinedExample = undefined;
const NullExample = null;
const SymbolExample = Symbol("unique");
const ObjectExample = { key: "value" };
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Type coercion</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Type coercion is when JavaScript automatically converts one data type into another when performing operations between different types. In general you can say there are two types of coercion: implicit coercion, which happens automatically, and explicit coercion, where you as a developer handle it manually.
            </p>

            <p class="font-semibold text-secondary-700 leading-relaxed">Examples of implicit coercion:</p>
            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(5 + "10"); //  “510” (number coerced into a string)
console.log("5" - 1); // 4 (string coerced into a number)
console.log(true + 1); // 2 (boolean coerced into number)
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Examples of explicit coercion:</p>
            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(Number("10")); // 10
console.log(String(10)); // “10”
console.log(Boolean(1)); // true
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              So why is this an issue? It can lead to unintended behaviour that can create bugs due to unexpected type changes. It also makes your code stink, making it harder to read and maintain. So how can we avoid this?
            </p>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The first thing you can implement in your code is to always use strict equality defined by === instead of non strict ==. Strict equality does not perform type conversion. So as an example if you have an if statement, don’t use loose comparisons like == and != but instead use the strict equality.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
if (userInput === "yes") {
  console.log("User agreed");
}
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              Explicitly convert types, instead of relying on implicit conversion, manually convert them yourself:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
let num = "42";
let convertedNum = Number(num);
console.log(convertedNum + 10); // 52
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The last thing we can do is to avoid mixing types in our operation.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
let num = "5";
console.log(Number(num) + 5); // 10
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              Instead of doing it like this:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(num + 5); // “55” (string concatenation)
</code>
            </pre>

            <div class="bg-primary-50 p-5 rounded-lg mb-6 border-l-4 border-primary-300">
              <p class="text-secondary-700 leading-relaxed">
                Or just fucking use TypeScript as this solves all these issues.
              </p>
            </div>
          </section>

          <section id="scopes" class="space-y-6 mb-12">
            <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
              <span class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">2</span>
              Scopes in JavaScript
            </h2>

            <p class="text-secondary-700 leading-relaxed mb-4">
              Scopes in JavaScript has three main types:
            </p>
            <ul class="space-y-2 mb-6">
              <li class="flex items-center text-secondary-700">
                <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
                Global scope
              </li>
              <li class="flex items-center text-secondary-700">
                <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
                Function scope
              </li>
              <li class="flex items-center text-secondary-700">
                <span class="inline-block w-2 h-2 rounded-full bg-primary-400 mr-3"></span>
                Block scope
              </li>
            </ul>

            <p class="font-semibold text-secondary-700 leading-relaxed">Global scope</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Variables declared outside of any function or block are defined as having global scope. You can access these variables from anywhere in your code.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const globalVariable = "You can access me anywhere";

function example() {
  console.log(globalVariable); // Accessible inside function
}

example(); // Output: “You can access me anywhere”
console.log(globalVariable); // Same output as above
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Function scope</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Variables declared inside a function are only accessible within the function where they are declared:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function testFunction() {
  const functionScopedConst = "I  only exist inside this function";
  console.log(functionScopedConst);
}

testFunction(); // Output: “I only exist inside this function”;
console.log(functionScopedConst); // ReferenceError: functionScopedConst is not defined
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Block scope</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Variables defined inside a block, which is declared by { }, like loops or conditionals, can only be accessed within this block. Here it’s important to notice that only let and const are block-scoped, var is not, and are one of the reasons why we should never use var. This can be seen in this example:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
if (true) {
  var a = "I’m var";
  let b = "I’m let";
  const c = "I’m const";
}

console.log(a); // “I’m var”
console.log(b); // Referenceerror: b is not defined
console.log(c); // ReferenceError: c is not defined
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Why do we prefer const then?</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Using const clarifies our intention, protects against us accidently reassigning, and improves the predictability of our code. It is important to note that const does not prevent mutations, it just prevents reassignments. If you want to make a object or array immutable, you can use JavaScripts build in method Object.freeze()
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const obj = Object.freeze({ name: "Aleksander" });
obj.name = "Anders"; // this will fail silently, unless you are using strict mode, then it will throw an error
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              So in summary we can say that the best practice for defining variables in Javascript are as following:
            </p>

            <ul class="space-y-2 mb-6 text-secondary-700 leading-relaxed list-outside list-disc ml-6">
              <li>Always use const by default as it clearly expresses your intent and prevents accidental reassignment</li>
              <li>Use let only when reassignment is absolutely needed</li>
              <li>Never use var in modern JavaScript</li>
            </ul>
          </section>

          <section id="functions" class="space-y-6 mb-12">
            <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
              <span class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">3</span>
              Functions in JavaScript
            </h2>

            <p class="text-secondary-700 leading-relaxed mb-4">
              When working with functions in JavaScript it is important to know about hoisting, function expressions, arrow functions and callbacks. Let’s work our way through these, and attempt to define them.
            </p>

            <p class="font-semibold text-secondary-700 leading-relaxed">Hoisting</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Hoisting means that function declarations are lifted into the top of the scope they are declared in before the code. In other words, you can call a function before it is defined in the code.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(getRandomInt(0,10));  // Works even though function is defined later

function getRandomInt(min, max){
  return Math.floor(Math.random() * (max + 1 - min) - min);
}
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The function getRandomInt is what we call a function declaration, so it is being hoisted to the top of our script. This allows us to call getRandomInt(0,10) before its definition.
            </p>

            <p class="font-semibold text-secondary-700 leading-relaxed">Function expressions vs arrow functions</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              Compared to function declarations, function expressions and arrow functions are not being hoisted. Let’s look at an example of function expression first.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const getRandomIntAnonymousFunction = function (min, max) {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The function is stored inside of a variable, and since const and let are not hoisted in the same way as a function declaration, making it impossible for us to call it before it is defined. The same goes for if we had defined it as an arrow function stored in a variable.
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const getRandomIntArrowFunction = (min, max) => {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Callbacks</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              A callback is a function that can be passed as an argument to another function, but doesn’t have to be passed. An example of this could be:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function genericPerformer(name, action) {
  return action(name); // Calls the function that was passed in
}
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The genericPerformer function accepts another function (action) as a parameter and calls it
              This is also called a high-order function, as it takes another function as an argument
            </p>

            <p class="text-secondary-700 leading-relaxed mb-4">
              So this makes it possible for us to use it like this:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
const codingAction = (name) => `${name} likes coding.`;
console.log(genericPerformer("Lasse", codingAction));
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              The function codingAction is passed to our genericPerformer function, which will call it with the parameter “Lasse”
            </p>

            <p class="font-semibold text-secondary-700 leading-relaxed">Passing anonymous functions as callbacks</p>
            <p class="text-secondary-700 leading-relaxed mb-4">
              As just shown with defining a separate function first, you can pass it directly as an anonymous function as the argument. This can be done like this:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
console.log(genericPerformer("Tara", (name) => `${name} owns at boxing`));
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              instead of writing it like this:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
function boxingAction(name) {
  return `${name} owns at boxing`;
}
console.log(genericPerformer("Tara", boxingAction));
</code>
            </pre>

            <p class="text-secondary-700 leading-relaxed mb-4">
              This use of an inline arrow function makes our code short and also more readable.
            </p>
          </section>

          <section id="loops" class="space-y-6 mb-12">
            <h2 class="text-2xl font-semibold mb-4 text-primary-800 flex items-center">
              <span class="inline-block w-6 h-6 rounded-full bg-primary-100 text-primary-700 text-xs text-center mr-3 flex items-center justify-center font-bold">4</span>
              Loops in JavaScript
            </h2>

            <p class="text-secondary-700 leading-relaxed mb-4">
              In JavaScript adopting a functional programming approach when working with arrays, promotes code that doesn’t stink, is more readable and maintainable. Using methods like map, filter and reduce allows us as developers to process data as pure functions, making them immutable, and without relying on explicit loops, and thereby minimizing side effects and maintaining high code predictability. Using these functional methods will make sure that we are not editing on the actual array, but instead creating a new one, which leads to no side effects. Let’s go through the ways of working with arrays in a functional way. Let’s look at some code examples:
            </p>

            <pre class="bg-secondary-900 text-white p-5 rounded-lg mb-6 border-l-4 border-primary-500 overflow-x-auto">
<code class="language-javascript">
// Example array
const numbers = [1, 2, 3, 4, 5]

// map - transforms each element and returns a new array
const doubled = numbers.map(num => num * 2);
// result: [2, 4, 6, 8, 10]

// filter - select elements that match a certain condition
const evens = numbers.filter(num => num % 2 === 0);
// result: [2, 4]

// reduce - accumulates values into a single result
const sum = numbers.reduce((total, num) => total + num, 0);
// result: 15
</code>
            </pre>

            <p class="font-semibold text-secondary-700 leading-relaxed">Choosing the right method for the right purpose</p>
            <ul class="space-y-2 mb-6 text-secondary-700 leading-relaxed list-outside list-disc ml-6">
              <li>Use map whenever we need to transform each element of an array into something else</li>
              <li>Use filter when we need to select a subset of the elements based on a certain condition</li>
              <li>Use reduce when we need to combine the elements of an array into a single value or structure</li>
              <li>Use a for loop only when finger counting</li>
            </ul>
          </section>

        </div>
      </div>
    </main>

  </div>

  <script type="module" src="../assets/js/sidebar.js"></script>
</body>
</html>
