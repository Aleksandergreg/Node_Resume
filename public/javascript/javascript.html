<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JavaScript Documentation</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
  <div class="min-h-screen flex">
    <div id="sidebar-container"></div>
    <main class="flex-1 p-8 max-w-4xl mx-auto">

      <h1 class="text-3xl font-bold mb-6">JavaScript</h1>

      <div class="mb-8">
        <h2 class="text-xl font-semibold mb-2">Contents</h2>
        <ul class="list-disc list-inside">
          <li><a href="#data-types" class="text-blue-600 hover:underline">Data types in JavaScript</a></li>
          <li><a href="#scopes" class="text-blue-600 hover:underline">Scopes in JavaScript</a></li>
          <li><a href="#functions" class="text-blue-600 hover:underline">Functions in JavaScript</a></li>
          <li><a href="#loops" class="text-blue-600 hover:underline">Loops in JavaScript</a></li>
        </ul>
      </div>
      <h2 id="data-types" class="text-2xl font-bold mb-4">Data types in JavaScript</h2>
      <p class="mb-4">
        JavaScript has 8 data types:
      </p>
      <ul class="py-8 space-y-4">
        <li>String</li>
        <li>Number</li>
        <li>BigInt</li>
        <li>Boolean</li>
        <li>Undefined</li>
        <li>Null</li>
        <li>Symbol</li>
        <li>Object</li>
      </ul>
      

      <p class="mb-4 font-semibold">Type coercion</p>
      <p class="mb-4">
        Type coercion is when JavaScript automatically converts one data type into another when performing operations between different types. In general you can say there are two types of coercion: implicit coercion, which happens automatically, and explicit coercion, where you as a developer handle it manually.
      </p>

      <p class="mb-4 font-semibold">Examples of implicit coercion:</p>
      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>console.log(5 + "10"); //  “510” (number coerced into a string)
console.log("5" - 1); // 4 (string coerced into a number)
console.log(true + 1); // 2 (boolean coerced into number)
</code>
      </pre>

      <p class="mb-4 font-semibold">Examples of explicit coercion:</p>
      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>console.log(Number("10")); // 10
console.log(String(10)); // “10”
console.log(Boolean(1)); // true
</code>
      </pre>

      <p class="mb-4">
        So why is this an issue? It can lead to unintended behaviour that can create bugs due to unexpected type changes. It also makes your code stink, making it harder to read and maintain. So how can we avoid this?
      </p>

      <p class="mb-4">
        The first thing you can implement in your code is to always use strict equality defined by === instead of non strict ==. Strict equality does not perform type conversion. So as an example if you have an if statement, don’t use loose comparisons like == and != but instead use the strict equality.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>if (userInput === "yes") {
  console.log("User agreed");
}
</code>
      </pre>

      <p class="mb-4">
        Explicitly convert types, instead of relying on implicit conversion, manually convert them yourself:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>let num = "42";
let convertedNum = Number(num);
console.log(convertedNum + 10); // 52
</code>
      </pre>

      <p class="mb-4">
        The last thing we can do is to avoid mixing types in our operation.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>let num = "5";
console.log(Number(num) + 5); // 10
</code>
      </pre>

      <p class="mb-4">
        Instead of doing it like this:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>console.log(num + 5); // “55” (string concatenation)
</code>
      </pre>

      <p class="mb-4">
        Or just fucking use TypeScript as this solves all these issues.
      </p>

      <h2 id="scopes" class="text-2xl font-bold mb-4">Scopes in JavaScript</h2>
      <p class="mb-4">
        Scopes in JavaScript has three main types:
      </p>
      <ul class="list-disc list-inside mb-4">
        <li>Global scope</li>
        <li>Function scope</li>
        <li>Block scope</li>
      </ul>

      <p class="mb-4 font-semibold">Global scope</p>
      <p class="mb-4">
        Variables declared outside of any function or block are defined as having global scope. You can access these variables from anywhere in your code.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>const globalVariable = "You can access me anywhere";

function example() {
  console.log(globalVariable); // Accessible inside function
}

example(); // Output: “You can access me anywhere”
console.log(globalVariable); // Same output as above
</code>
      </pre>

      <p class="mb-4 font-semibold">Function scope</p>
      <p class="mb-4">
        Variables declared inside a function are only accessible within the function where they are declared:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>function testFunction() {
  const functionScopedConst = "I  only exist inside this function";
  console.log(functionScopedConst);
}

testFunction(); // Output: “I only exist inside this function”;
console.log(functionScopedConst); // ReferenceError: functionScopedConst is not defined
</code>
      </pre>

      <p class="mb-4 font-semibold">Block scope</p>
      <p class="mb-4">
        Variables defined inside a block, which is declared by { }, like loops or conditionals, can only be accessed within this block. Here it’s important to notice that only let and const are block-scoped, var is not, and are one of the reasons why we should never use var. This can be seen in this example:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>if (true) {
  var a = "I’m var";
  let b = "I’m let";
  const c = "I’m const";
}

console.log(a); // “I’m var”
console.log(b); // Referenceerror: b is not defined
console.log(c); // ReferenceError: c is not defined
</code>
      </pre>

      <p class="mb-4 font-semibold">Why do we prefer const then?</p>
      <p class="mb-4">
        Using const clarifies our intention, protects against us accidently reassigning, and improves the predictability of our code. It is important to note that const does not prevent mutations, it just prevents reassignments. If you want to make a object or array immutable, you can use JavaScripts build in method Object.freeze()
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>const obj = Object.freeze({ name: "Aleksander" });
obj.name = "Anders"; // this will fail silently, unless you are using strict mode, then it will throw an error
</code>
      </pre>

      <p class="mb-4">
        So in summary we can say that the best practice for defining variables in Javascript are as following:
      </p>

      <ul class="list-disc list-inside mb-4">
        <li>Always use const by default as it clearly expresses your intent and prevents accidental reassignment</li>
        <li>Use let only when reassignment is absolutely needed</li>
        <li>Never use var in modern JavaScript</li>
      </ul>

      <h2 id="functions" class="text-2xl font-bold mb-4">Functions in JavaScript</h2>
      <p class="mb-4">
        When working with functions in JavaScript it is important to know about hoisting, function expressions, arrow functions and callbacks. Let’s work our way through these, and attempt to define them.
      </p>

      <p class="mb-4 font-semibold">Hoisting</p>
      <p class="mb-4">
        Hoisting means that function declarations are lifted into the top of the scope they are declared in before the code. In other words, you can call a function before it is defined in the code.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>console.log(getRandomInt(0,10));  // Works even though function is defined later

function getRandomInt(min, max){
  return Math.floor(Math.random() * (max + 1 - min) - min);
}
</code>
      </pre>

      <p class="mb-4">
        The function getRandomInt is what we call a function declaration, so it is being hoisted to the top of our script. This allows us to call getRandomInt(0,10) before its definition.
      </p>

      <p class="mb-4 font-semibold">Function expressions vs arrow functions</p>
      <p class="mb-4">
        Compared to function declarations, function expressions and arrow functions are not being hoisted. Let’s look at an example of function expression first.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>const getRandomIntAnonymousFunction = function (min, max) {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
      </pre>

      <p class="mb-4">
        The function is stored inside of a variable, and since const and let are not hoisted in the same way as a function declaration, making it impossible for us to call it before it is defined. The same goes for if we had defined it as an arrow function stored in a variable.
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>const getRandomIntArrowFunction = (min, max) => {
  return Math.floor(Math.random() * (max + 1 - min) - min);	
};
</code>
      </pre>

      <p class="mb-4 font-semibold">Callbacks</p>
      <p class="mb-4">
        A callback is a function that can be passed as an argument to another function, but doesn’t have to be passed. An example of this could be:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>function genericPerformer(name, action) {
  return action(name); // Calls the function that was passed in
}
</code>
      </pre>

      <p class="mb-4">
        The genericPerformer function accepts another function (action) as a parameter and calls it
        This is also called a high-order function, as it takes another function as an argument
      </p>

      <p class="mb-4">
        So this makes it possible for us to use it like this:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>const codingAction = (name) => \`\${name} likes coding.\`;
console.log(genericPerformer("Lasse", codingAction));
</code>
      </pre>

      <p class="mb-4">
        The function codingAction is passed to our genericPerformer function, which will call it with the parameter “Lasse”
      </p>

      <p class="mb-4 font-semibold">Passing anonymous functions as callbacks</p>
      <p class="mb-4">
        As just shown with defining a separate function first, you can pass it directly as an anonymous function as the argument. This can be done like this:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>console.log(genericPerformer("Tara", (name) => \`\${name} owns at boxing\`));
</code>
      </pre>

      <p class="mb-4">
        instead of writing it like this:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>function boxingAction(name) {
  return \`\${name} owns at boxing\`;
}
console.log(genericPerformer("Tara", boxingAction));
</code>
      </pre>

      <p class="mb-4">
        This use of an inline arrow function makes our code short and also more readable.
      </p>

      <h2 id="loops" class="text-2xl font-bold mb-4">Loops in JavaScript</h2>
      <p class="mb-4">
        In JavaScript adopting a functional programming approach when working with arrays, promotes code that doesn’t stink, is more readable and maintainable. Using methods like map, filter and reduce allows us as developers to process data as pure functions, making them immutable, and without relying on explicit loops, and thereby minimizing side effects and maintaining high code predictability. Using these functional methods will make sure that we are not editing on the actual array, but instead creating a new one, which leads to no side effects. Let’s go through the ways of working with arrays in a functional way. Let’s look at some code examples:
      </p>

      <pre class="bg-gray-800 text-white p-4 rounded mb-4 whitespace-pre">
<code>// Example array
const numbers = [1, 2, 3, 4, 5]

// map - transforms each element and returns a new array
const doubled = numbers.map(num => num * 2);
// result: [2, 4, 6, 8, 10]

// filter - select elements that match a certain condition
const evens = numbers.filter(num => num % 2 === 0);
// result: [2, 4]

// reduce - accumulates values into a single result
const sum = numbers.reduce((total, num) => total + num, 0);
// result: 15
</code>
      </pre>

      <p class="mb-4 font-semibold">Choosing the right method for the right purpose</p>
      <ul class="list-disc list-inside mb-4">
        <li>Use map whenever we need to transform each element of an array into something else</li>
        <li>Use filter when we need to select a subset of the elements based on a certain condition</li>
        <li>Use reduce when we need to combine the elements of an array into a single value or structure</li>
        <li>Use a for loop only when finger counting</li>
      </ul>

    </main>
  </div>
  <script type="module" src="../assets/js/sidebar.js"></script>
</body>
</html>
